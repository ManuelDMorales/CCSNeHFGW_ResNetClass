# CCSNeHFGW_ResNetClass
Python implementation for characterizing the high frequency feature (HFF) in Gravitational Waves (GW) emitted by Core-Collapse Supernovae (CCSNe). This implementation begins with the generation of a dataset scalogram images containg GW events embedded in real LIGO-Virgo noise, and then apply a ResNet50 model to classify images according the slope of the HFF present in the scalograms. Written by Manuel D. Morales, <manueld.morales@academicos.udg.mx>.

<b><ins>The astrophysical problem</ins></b>

CCSNe are one of the most violents phenomena in the universe, in which diverse physical processes are involved. They have their origin in the final life-stage of a massive star, with initial masses $9M_{\odot} \lesssim M \lesssim 24M_{\odot}$ for metallicties less than solar. For the case of a remaining iron nuclei, these dissociate into alpha particles and free nucleons, thermal energy is absorbed, and the core is contracted and finally collapse is produced. After this collapse, a proto-neutron star (PNS) is formed, and a shock wave (the stellar envelope) is launched to the interstellar medium.

Because here we are in the strong gravity regime, GW (stochastic) signals are emitted, and it is expected that this GW carry information about the physical process of the PNS. Indeed, the HFF is one of the signatures of CCSNe GW which contains information about the PNS pulsation, emerging in all current numerical relativity simulations. On time-frequency (TF) spectrograms/scalograms, the HFF has monotonically increasing profile. In Fig. 1 are spectrograms of two simulated CCSNe GW, in which the HFF appears.

![Andresen2017](Figures/waveforms_numerical.jpg)
<b>Figure 1</b>. Two examples of the HFF in numerical CCSNe GW: Andresen et al 2017, and Kuroda et al 2017.

Until now, CCSNe GW still are not been detected, then we need to anticipate techniques to detect and characterize features as the HFF.

<b><ins>Technical details about this work</ins></b>

As a first case of study, in this work we developed a robust implementation to characterize the HFF present in phenomenological waveforms -a kind of waveforms that was introduced in [Lopez et al 2021](https://doi.org/10.1103/PhysRevD.103.063011) and later we also generate with our own codes [Tiznado et al 2023](https://www.rcs.cic.ipn.mx/2023_152_6/). These phenomenological waveforms do not have physical information such as those generated by multi-dimensional CCSNe simulations, but are useful to mimic the effect of the HFF in the time-frequency representation. The characterization is performed using a 3-label ResNet50 classifier, defining three ranges of the HFF slope:

- <b>Class 1</b>: $1,620 \lt \text{Slope}_{HFF} \lt 4,990$
- <b>Class 2</b>: $1,450 \lt \text{Slope}_{HFF} \lt 1,620$
- <b>Class 3</b>: $950 \lt \text{Slope}_{HFF} \lt 1,450$

Fig. 2 shows three representative phenomenological waveforms, each one belonging to each class, depending on the slope of the HFF.

![Phenom_WF](Figures/waveforms_phenom.jpg)
<b>Figure 2</b>. Scalograms (based on a Morlet Wavelet Transform) of three phenomenological waveforms

The procedure is to input class-tagged and pixelized spectrograms of phenomenological waveforms embedded in real LIGO-Virgo noise to the ResNet50 algorithm, such that the algorithm, after the training, be able to discriminate the class of each image sample during the test procedure.

<b><ins>Implementation structure</ins></b>

Jupyter python notebooks are in the folder "Codes", and they was though to be sequentially run. They form a process in three stages, each one with its respective scripts:

<b>Stage 1, Raw data prepatation</b>
  - <b>Noise_Explorer.ipynb</b>: Noise data download. These data come from the LIGO-Virgo detectors, run O3b, and they are downloaded from the GW Open Science Center. Strain time series and the Amplitude Spectral Densities are explored. Sensibility of the three detectors is compared. Noise strain segments are choosen such that their duration time is $4,096 s$, with sampling frequency $4,096 Hz$.
  - <b>Waveforms_Preparation.ipynb</b>: We draw on 600 phenomenological CCSNe waveforms (200 each class). This script load all these waveforms and apply a resampling to have the sample sampling frequency of noise dada. Moreover, a rescaling is apply by multiplying each waveform by a factor. In numerical simulations of CCSNe GW, choice of this factor is motivated by the distance of the emitting source. However, this phenomenological waveforms does not included information about the distance. Therefore, the choice of the rescaling factor will be motivated by the signal-to-noise ratio (SNR) of GW events which are monitored in the Populations_explorer.ipynb script (see stage 2).
  - <b>Make_Injections.ipynb</b>: This script apply the software injection procedure by randomly selecting waveforms of one class (which were prepared in the previous script). Crucial input parameters are: time difference between injections (dt_inj, in seconds), fluctuation range around dt_inj in which injections will be performed (jit_lim, in seconds), and time segment around each in which the SNR is computed using the PyCBC library.
  - <b>Prepare_Data.ipynb</b>: We apply a whitening and a band-pass filtering, in order to approximate noise to a Gaussian process and easily recover injected CCSNe GW. Both procedures are also applied through the PyCBC library. Filter's band is astrophysically motivated, depending on the type of GW that we want to detect. After this pre-processing the Amplitude Spectral Sensity (ASD) is plotted as a check.

<b>Stage 2, Image samples generation</b>
  - <b>Build_StrainData.ipynb</b>: This script generates the window strain samples.
  - <b>Populations_Explorer.ipynb</b>: Histogram exploration of injected events in window strain samples. SNR values, HFF slopes, etc. SNR exploration is crucial, in order to select scaling factor of phenomenological templates in Waveforms_Preparation.ipynb script.
  - <b>Convert_StrainImage.ipynb</b>: Conversion of strain samples to images of time-frequency scalograms, applying a Morlet wavelet transformation. Scalograms are pixelized as images of dimension 64x63, with 3 channels (RGB).

<b>Stage 3, ResNet50 classification</b>
  - <b>Apply_ResNet50.ipynb</b>

<b><ins>Suggestions to easyly run the codes</ins></b>
